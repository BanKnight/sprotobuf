{"version":3,"sources":["webpack://sprotobuf/webpack/bootstrap","webpack://sprotobuf/./src/head.js","webpack://sprotobuf/./src/browser.js","webpack://sprotobuf/./src/parse.js","webpack://sprotobuf/./src/encode.js","webpack://sprotobuf/./src/decode.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","lib","require","load","async","url","Promise","resolve","reject","xmlhttp","XMLHttpRequest","onreadystatechange","readyState","status","root","parse","responseText","e","Error","open","send","delimRe","whitespaceRe","nameRe","typeRefRe","BKDRHash","str","max","hash","length","charCodeAt","source","proto","messages","Map","services","token","offset","line","illegal","subject","next","curr","undefined","prev","repeat","test","charAt","end","lastIndex","substring","skip","expected","actual","parseCommon","parent","parseInt","parseOption","message","fields","field","parseType","id","set","parseMessage","service","methods","parseMethod","type","parseService","keyType","indexOf","valueType","val","parseMapType","parseArrayType","parseBasicType","method","req","resp","param","push","values","that_type","encoder","to_msg","writer","obj","obj_to_msg","to_rpc","args","array","split","service_name","method_name","append_uint32","pos","len","append_uint8","arg","write_type","replace_uint8","to_resp","ret","to_error","code","reason","append_uint16","append_string","replace_uint16","tp","target","write_val","one","size","append_bytes","decoder","from_msg","reader","msg_to_obj","from_rpc","helper","read_uint32","service_id","method_id","read_uint8","index","read_type","from_resp","from_error","read_uint16","read_string","field_id","read_val","read_bytes"],"mappings":"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","file":"sprotobuf.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = {}","let lib = module.exports = require(\"./head\")\n\nrequire(\"./parse\")\nrequire(\"./encode\")\nrequire(\"./decode\")\n\nlib.load = async function (url)\n{\n    return new Promise((resolve, reject) =>\n    {\n        let xmlhttp = new XMLHttpRequest();\n\n        xmlhttp.onreadystatechange = function ()\n        {\n            if (4 !== xmlhttp.readyState)\n                return;\n\n            if (0 !== xmlhttp.status && 200 !== xmlhttp.status)\n            {\n                reject(Error(\"status \" + xmlhttp.status))\n                return\n            }\n\n            try\n            {\n                let root = lib.parse(xmlhttp.responseText)\n                resolve(root)\n            }\n            catch (e)\n            {\n                reject(e)\n            }\n        }\n\n        xmlhttp.open(\"GET\", url, true);\n        xmlhttp.send(null);\n    })\n\n}","const lib = require(\"./head\")\n\nconst delimRe = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\nconst setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\n\nconst nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/\n\nconst s = [\n\n    \"double\",   // 0\n    \"float\",    // 1\n\n    \"uint8\",\n    \"int8\",\n\n    \"int16\",   // 4\n    \"uint16\",  // 5\n\n    \"int32\",    // 2\n    \"uint32\",   // 3\n\n    \"int64\",    // 7\n    \"uint64\",   // 8\n\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction BKDRHash(str, max)\n{\n    max = max || 29989\n\n    let seed = 131; // 31 131 1313 13131 131313 etc..\n    let hash = 0;\n\n    for (let i = 0; i < str.length; ++i)\n    {\n        hash = hash * seed + str.charCodeAt(i)\n    }\n\n    return hash % max + 1\n}\n\n\nlib.parse = function (source)\n{\n    const proto = {\n        messages: new Map(),           //[name/id]\n        services: new Map(),        //[name/id]\n    }\n\n    let offset = 0\n    let length = source.length\n    let line = 1\n\n    function illegal(subject)\n    {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n    function next()\n    {\n        let curr = undefined\n        let prev = undefined\n        let repeat = undefined\n\n        do\n        {\n            if (offset === length)\n                return null;\n\n            repeat = false;\n\n            while (whitespaceRe.test(curr = source.charAt(offset)))\n            {\n                if (curr === \"\\n\")\n                    ++line;\n                if (++offset === length)\n                    return null;\n            }\n\n            if (source.charAt(offset) === \"/\")  //comments\n            {\n                if (++offset === length)\n                {\n                    throw illegal(\"comment\");\n                }\n                if (source.charAt(offset) === \"/\") //line\n                {\n                    while (source.charAt(++offset) !== \"\\n\")\n                    {\n                        if (offset === length)\n                        {\n                            return null;\n                        }\n                    }\n                    ++line;\n                    ++offset;\n                    repeat = true;\n                }\n                else if ((curr = source.charAt(offset)) === \"*\")\n                {\n                    do\n                    {\n                        if (curr === \"\\n\")\n                        {\n                            ++line;\n                        }\n                        if (++offset === length)\n                        {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = source.charAt(offset);\n                    } while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    repeat = true;\n                }\n            }\n\n        } while (repeat)\n\n        let end = offset;\n        delimRe.lastIndex = 0;\n        let delim = delimRe.test(source.charAt(end++));\n        if (!delim)\n            while (end < length && !delimRe.test(source.charAt(end)))\n                ++end;\n\n        let token = source.substring(offset, offset = end);\n\n        return token;\n    }\n\n    function skip(expected)\n    {\n        var actual = next(),\n            equals = actual === expected;\n        if (equals)\n        {\n            return true;\n        }\n        throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n    }\n\n    function parseCommon(parent, token)\n    {\n        switch (token)\n        {\n            case \"option\":\n                parseOption(parent, token);\n                return true;\n            case \"message\":\n                parseMessage(parent, token);\n                return true;\n            case \"service\":\n                parseService(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    let token;\n\n    while ((token = next()) !== null)\n    {\n        switch (token)      //这里的case 留作之后扩展\n        {\n            default:\n\n                /* istanbul ignore else */\n                if (parseCommon(proto, token))\n                {\n                    continue;\n                }\n\n                /* istanbul ignore next */\n                throw illegal(token);\n        }\n    }\n\n    function parseOption(parent, token)\n    {\n        /* istanbul ignore if */\n        if (!typeRefRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        let name = token;\n\n        skip(\"=\");\n\n        parent[name] = parseInt(next())\n\n        skip(\";\")\n    }\n\n    function parseMessage(parent, token)\n    {\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        const message = {\n            name: token,\n            fields: new Map(),      //[name/id]\n        }\n\n        skip(\"{\")\n\n        while ((token = next()) != \"}\")\n        {\n            if (parseCommon(message, token))\n                continue;\n\n            let field = parseType(token)\n\n            field.name = next();\n\n            if (!nameRe.test(field.name))\n                throw illegal(field.name, \"name\");\n\n            skip(\"=\");\n\n            field.id = parseInt(next())\n\n            skip(\";\")\n\n            if (message.fields.get(field.name))\n            {\n                throw illegal(\"same field name:\" + field.name)\n            }\n\n            message.fields.set(field.name, field)\n\n            if (message.fields.get(field.id))\n            {\n                throw illegal(\"same id:\" + field.id)\n            }\n            message.fields.set(field.id, field)\n        }\n\n        if (parent.messages.get(message.name) != null)\n        {\n            throw illegal(message.name)\n        }\n\n        parent.messages.set(message.name, message)\n\n        if (message.id === undefined)\n        {\n            message.id = BKDRHash(message.name)\n\n            while (parent.messages.get(message.id) != null)\n            {\n                message.id++\n            }\n        }\n        parent.messages.set(message.id, message)\n    }\n\n    function parseService(parent, token)\n    {\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"service name\");\n\n        let service = {\n            name: token,\n            methods: new Map(),     //[name/id]\n        }\n\n        skip(\"{\")\n\n        while ((token = next()) != \"}\")\n        {\n            if (parseCommon(service, token))\n                continue;\n\n            switch (token)\n            {\n                case \"rpc\":\n                    parseMethod(service, token);\n                    break\n                default:\n                    throw illegal(type.name)\n            }\n        }\n\n        if (parent.services.get(service.name) != null)\n        {\n            throw illegal(services.name)\n        }\n\n        parent.services.set(service.name, service)\n\n        if (service.id === undefined)\n        {\n            service.id = BKDRHash(service.name)\n\n            while (parent.services.get(service.id) && parent.messages.get(service.id))\n            {\n                service.id++\n            }\n        }\n\n        if (parent.services.get(service.id))\n        {\n            throw illegal(\"same id:\" + service.id)\n        }\n\n        parent.services.set(service.id, service)\n    }\n\n    function parseType(token)\n    {\n        switch (token)\n        {\n            case \"<\":\n                return parseMapType();\n            case \"[\":\n                return parseArrayType();\n            default:\n                return parseBasicType(token);\n        }\n    }\n\n    function parseMapType(type)\n    {\n        let keyType = next();\n\n        if (s.indexOf(keyType) == -1)\n        {\n            throw illegal(\"must be basic type:\" + keyType);\n        }\n\n        skip(\",\");\n        let valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n\n        return {\n            key: keyType,\n            val: valueType,\n        }\n    }\n\n    function parseArrayType()\n    {\n        let valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\"]\");\n\n        return {\n            key: false,\n            val: valueType,\n        }\n    }\n\n    function parseBasicType(token)\n    {\n        let valueType = token\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType);\n\n        return {\n            val: valueType,\n        }\n    }\n\n    function parseMethod(service, token)\n    {\n        let name = next();\n\n        if (!nameRe.test(name))\n            throw illegal(name)\n\n        let method = {\n            name: name,\n            req: [],\n            resp: undefined,\n        }\n\n        skip(\"(\")\n        while ((token = next()) != \")\")\n        {\n            if (token == \",\")\n            {\n                continue\n            }\n\n            let param = parseType(token)\n\n            param.name = next();\n\n            if (!nameRe.test(param.name))\n                throw illegal(param.name, \"name\");\n\n            method.req.push(param)\n        }\n\n        skip(\"return\")\n\n        skip(\"(\")\n\n        if ((token = next()) != \")\")\n        {\n            method.resp = parseType(token)\n            skip(\")\")\n        }\n\n        skip(\"{\")\n\n        while ((token = next()) != \"}\")\n        {\n            if (parseCommon(method, token))\n                continue;\n\n            throw illegal(token)\n        }\n\n        service.methods.set(method.name, method)\n\n        if (method.id === undefined)\n        {\n            method.id = BKDRHash(method.name)\n\n            while (service.methods.get(method.id))\n            {\n                method.id++\n            }\n        }\n        if (service.methods.get(method.id))\n        {\n            throw illegal(\"method id:\" + method.id)\n        }\n        service.methods.set(method.id, method)\n    }\n\n    for (let message of proto.messages.values())\n    {\n        for (let field of message.fields.values())\n        {\n            if (typeof (field.val) == \"object\")\n            {\n                continue\n            }\n            if (s.indexOf(field.val) > -1)     //basic type\n            {\n                continue\n            }\n            let that_type = proto.messages.get(field.val)\n            if (that_type == null)\n            {\n                throw Error(\"no such type:\" + field.val)\n            }\n\n            // console.log(`${field.val} ${message.name}.${field.name}`)\n\n            field.val = that_type\n        }\n    }\n\n    for (let service of proto.services.values())\n    {\n        for (let method of service.methods.values())\n        {\n            for (let i = 0; i < method.req.length; ++i)\n            {\n                let param = method.req[i]\n\n                if (typeof (param.val) == \"object\")\n                {\n                    continue\n                }\n                if (s.indexOf(param.val) > -1)\n                {\n                    continue\n                }\n\n                let that_type = proto.messages.get(param.val)\n                if (that_type == null)\n                {\n                    throw Error(\"no such type:\" + param.val)\n                }\n                param.val = that_type\n            }\n        }\n    }\n\n    return proto\n}","let lib = require(\"./head\")\n\nlet encoder = {}\n\nlib.to_msg = function (root, writer, name, obj)\n{\n    let message = root.messages.get(name)\n    if (message == null)\n    {\n        throw Error(\"no such message:\" + name)\n    }\n\n    encoder.obj_to_msg(root, writer, message, obj)\n}\n\nlib.to_rpc = function (root, writer, name, ...args)\n{\n    let array = name.split(\".\")\n    let service_name = array[0]\n    let method_name = array[1]\n\n    let service = root.services.get(service_name)\n    if (service == null)\n    {\n        throw Error(\"no such service:\" + service_name)\n    }\n\n    let method = service.methods.get(method_name)\n    if (method == null)\n    {\n        throw Error(\"no such method:\" + name)\n    }\n\n    if (args.length < method.req.length)\n    {\n        throw Error(\"more params required:\" + name)\n    }\n\n    writer.append_uint32(service.id << 16 | method.id)\n\n    let pos = writer.offset\n    let len = 0\n\n    writer.append_uint8(0)\n\n    //以下这么写是为了可以实现null\n    for (let i = 0; i < method.req.length; ++i)\n    {\n        let arg = args[i]\n        if (arg == null)\n        {\n            continue\n        }\n\n        writer.append_uint8(i)\n        encoder.write_type(root, writer, method.req[i], arg)\n\n        len++\n    }\n\n    writer.replace_uint8(len, pos)\n}\n\nlib.to_resp = function (root, writer, name, ret)\n{\n    let array = name.split(\".\")\n    let service_name = array[0]\n    let method_name = array[1]\n\n    let service = root.services.get(service_name)\n    if (service == null)\n    {\n        throw Error(\"no such service:\" + service_name)\n    }\n\n    let method = service.methods.get(method_name)\n    if (method == null)\n    {\n        throw Error(\"no such method:\" + name)\n    }\n\n    if (method.resp)\n    {\n        encoder.write_type(root, writer, method.resp, ret)\n    }\n}\n\nlib.to_error = function (root, writer, code, reason)\n{\n    writer.append_uint16(code)\n    writer.append_string(reason)\n}\n\nencoder.obj_to_msg = function (root, writer, message, obj)\n{\n\n    let pos = writer.offset\n\n    writer.append_uint16(0)     //占用位置,这里写长度\n\n    let len = 0\n    for (let key in obj)\n    {\n        let field = message.fields.get(key)\n\n        if (field == null)\n        {\n            continue\n        }\n\n        let val = obj[key]\n\n        writer.append_uint8(field.id)\n\n        encoder.write_type(root, writer, field, val)\n\n        len++\n    }\n\n    writer.replace_uint16(len, pos)\n}\n\nencoder.write_type = function (root, writer, tp, target)\n{\n    if (tp.key === undefined)\n    {\n        encoder.write_val(root, writer, tp.val || tp, target)\n    }\n    else if (tp.key === false)   //array\n    {\n        writer.append_uint16(target.length)\n        for (let one of target)\n        {\n            encoder.write_val(root, writer, tp.val, one)\n        }\n    }\n    else    //map\n    {\n        if (target instanceof Map)\n        {\n            writer.append_uint16(target.size)\n\n            for (let [key, val] of target)\n            {\n                encoder.write_val(root, writer, tp.key, key)\n                encoder.write_type(root, writer, tp.val, val)\n            }\n        }\n        else\n        {\n            let pos = writer.offset\n            let len = 0\n\n            writer.append_uint16(len)\n\n            for (let key in target)\n            {\n                let val = target[key]\n\n                encoder.write_val(root, writer, tp.key, key)\n                encoder.write_type(root, writer, tp.val, val)\n\n                len++\n            }\n\n            writer.replace_uint16(len, pos)\n        }\n    }\n}\n\nencoder.write_val = function (root, writer, tp, val)\n{\n    switch (tp)\n    {\n        case \"double\":   // 0\n        case \"float\":    // 1\n        case \"uint8\":\n        case \"int8\":\n        case \"int16\":   // 4\n        case \"uint16\":  // 5\n        case \"int32\":    // 2\n        case \"uint32\":   // 3\n        case \"int64\":    // 7\n        case \"uint64\":   // 8\n            writer[`append_${tp}`](val)\n            break\n        case \"bool\":     // 12\n            writer.append_uint8(val ? 1 : 0)\n            break\n        case \"string\":   // 13\n            writer.append_string(val)\n            break\n        case \"bytes\":     // 14\n            writer.append_bytes(val)\n            break\n        default:\n            {\n                encoder.obj_to_msg(root, writer, tp, val)\n            }\n    }\n}\n\n\n","let lib = require(\"./head\")\nlet decoder = {}\n\nlib.from_msg = function (root, reader, name)\n{\n    let message = root.messages.get(name)\n    if (message == null)\n    {\n        throw Error(\"no such message:\" + name)\n    }\n    return decoder.msg_to_obj(root, reader, message)\n}\n\nlib.from_rpc = function (root, reader)\n{\n    let helper = reader.read_uint32()\n\n    let service_id = helper >> 16\n    let method_id = helper & 0xFFFF\n\n    let service = root.services.get(service_id)\n    if (service == null)\n    {\n        throw Error(\"no such service:\" + service_id)\n    }\n    let method = service.methods.get(method_id)\n    if (method == null)\n    {\n        throw Error(\"no such method:\" + method)\n    }\n\n    let req = {}\n    let len = reader.read_uint8()\n\n    for (let i = 0; i < len; ++i)\n    {\n        let index = reader.read_uint8()\n        let param = method.req[index]\n        let arg = decoder.read_type(root, reader, param)\n\n        req[param.name] = arg\n    }\n\n    return {\n        service: service.name,\n        method: method.name,\n        req: req\n    }\n}\n\nlib.from_resp = function (root, reader, name)\n{\n    let array = name.split(\".\")\n    let service_name = array[0]\n    let method_name = array[1]\n\n    let service = root.services.get(service_name)\n    if (service == null)\n    {\n        throw Error(\"no such service:\" + service_name)\n    }\n\n    let method = service.methods.get(method_name)\n    if (method == null)\n    {\n        throw Error(\"no such method:\" + name)\n    }\n\n    let ret = decoder.read_type(root, reader, method.resp)\n\n    return ret\n}\n\nlib.from_error = function (root, reader)\n{\n    return [reader.read_uint16(), reader.read_string()]\n}\n\ndecoder.msg_to_obj = function (root, reader, message)\n{\n    let obj = {}\n    let len = reader.read_uint16()\n    for (let i = 0; i < len; ++i)\n    {\n        let field_id = reader.read_uint8()\n        let field = message.fields.get(field_id)\n\n        if (field == null)\n        {\n            throw Error(\"no such field id:\" + field_id)\n        }\n\n        obj[field.name] = decoder.read_type(root, reader, field)\n    }\n    return obj\n}\n\ndecoder.read_type = function (root, reader, tp)\n{\n    if (tp.key === undefined)\n    {\n        return decoder.read_val(root, reader, tp.val || tp)\n    }\n\n    if (tp.key === false)   //array\n    {\n        let target = []\n        let len = reader.read_uint16()\n\n        for (let i = 0; i < len; ++i)\n        {\n            target.push(decoder.read_type(root, reader, tp.val))\n        }\n\n        return target\n    }\n\n    let target = new Map()\n    let len = reader.read_uint16()\n\n    for (let i = 0; i < len; ++i)\n    {\n        let key = decoder.read_val(root, reader, tp.key)\n        let val = decoder.read_type(root, reader, tp.val)\n\n        target.set(key, val)\n    }\n\n    return target\n}\n\ndecoder.read_val = function (root, reader, tp)\n{\n    let val\n    switch (tp)\n    {\n        case \"double\":   // 0\n        case \"float\":    // 1\n        case \"uint8\":\n        case \"int8\":\n        case \"int16\":   // 4\n        case \"uint16\":  // 5\n        case \"int32\":    // 2\n        case \"uint32\":   // 3\n        case \"int64\":    // 7\n        case \"uint64\":   // 8\n            val = reader[`read_${tp}`]()\n            break\n        case \"bool\":     // 12\n            val = reader.read_uint8() == 1\n            break\n        case \"string\":   // 13\n            val = reader.read_string()\n            break\n        case \"bytes\":     // 14\n            val = reader.read_bytes()\n            break\n        default:\n            {\n                val = decoder.msg_to_obj(root, reader, tp)\n            }\n    }\n    return val\n}"],"sourceRoot":""}